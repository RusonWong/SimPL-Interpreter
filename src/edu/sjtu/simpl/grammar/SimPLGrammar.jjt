/**
 * JJTree template file created by SF JavaCC plugin 1.5.17+ wizard for JavaCC 1.5.0+
 */options{  JDK_VERSION = "1.5";
  NODE_DEFAULT_VOID = false;
  MULTI=true;
  KEEP_LINE_COLUMN = false;}PARSER_BEGIN(SimPL)package edu.sjtu.simpl.grammar;

public class SimPL{  public static void main(String args [])  {    System.out.println("Reading from standard input...");    //System.out.print("Enter an expression like \"1+(2+3)*var;\" :");    new SimPL(System.in);    try    {
      System.out.println("-------");      SimpleNode n = SimPL.Program();      n.dump("");      System.out.println("-------");    }    catch (Exception e)    {      System.out.println("Oops.");      System.out.println(e.getMessage());    }  }}PARSER_END(SimPL)SKIP :{  " "| "\t"| "\n"| "\r"| < "//" (~[ "\n", "\r" ])*    (      "\n"    | "\r"    | "\r\n"    ) >| < "/*" (~[ "*" ])* "*"    (      ~[ "/" ] (~[ "*" ])* "*"    )*    "/" >}TOKEN : /* LITERALS */{  < INTEGER_LITERAL :    < DECIMAL_LITERAL > ([ "l", "L" ])?  | < HEX_LITERAL > ([ "l", "L" ])?  | < OCTAL_LITERAL > ([ "l", "L" ])?     >| < #DECIMAL_LITERAL : [ "1"-"9" ] ([ "0"-"9" ])* >| < #HEX_LITERAL : "0" [ "x", "X" ] ([ "0"-"9", "a"-"f", "A"-"F" ])+ >| < #OCTAL_LITERAL : "0" ([ "0"-"7" ])* >}

TOKEN : /* key words*/
{	< LET : "let">
	| < IN : "in" >
	| < IF : "if" >
	| < THEN : "then">
	| < ELSE : "else" >
	| < WHILE: "while" >
	| < DO : "do" >
	| < END : "end" >
	| < FST : "fst" >
	| < SND : "snd" >
	| < HEAD : "head">
	| < TAIL : "tail" >
	
	| < FUN : "fun" >
	| < TRUE:"true" >
	| < FALSE:"false" >

	| < NIL :"nil">
}

//TOKEN : /*type*/
/*
{
	< INT : "int" >
	| < BOOL : "bool" >
	| < NIL : "nil" >
}
*/
TOKEN : /**/
{
	  < COMMA : "," >
	| < SEMICOLON : ";" >
	| < COLONCOLON : "::" >
	| < COLONEQUAL : ":=" >
	
	//uop
	| < NEGATION : "~" >
	| < NOT : "not" >
	//bop
	| < PLUS : "+" >
	| < MINUS : "-" >
	| < TIMES : "*" >
	| < DIVIDE : "/" >
	| < BIGGER : ">" >
	| < LESS : "<" >
	| < AND : "and" >
	| < OR : "or" >
	| < EQUAL : "=" >
	
	| < LEFTPARENTHESES : "(" >
	| < RIGHTPARENTHESES : ")" >
	| < LBRACKET : "[" >
	| < RBRACKET : "]" >
	| < LBRACE : "{" >
	| < RBRACE : "}" >

	| < ARROW : "->" >

}
TOKEN : /* IDENTIFIERS */{  < IDENTIFIER :    < LETTER >    (      < LETTER >    | < DIGIT >    )* >| < #LETTER : [ "a"-"z", "A"-"Z" ] >| < #DIGIT : [ "0"-"9" ] >}
SimpleNode Program() :{}{  Expression()  {    return jjtThis;  } "!"}
//TODOvoid Expression() :{}{
 	(
 	  Identifier()   //id 	| LOOKAHEAD(2)Value()        //value
 	//| LOOKAHEAD(2)Pair()		//(e1,e2)
 	//| LOOKAHEAD(2)Application()	//(e1 e2)
 	| UopExp()					//uop e
 	| LetExp()					//let x =e1 in e2 end
 	| ConditionalExp()			//if e1 then e2 else e3 end
 	| WhileLoopExp()			//while e1 do e2 end
 	| FstExp()					//fst e
 	| SndExp()					//snd e
 	| HeadExp()					//head e
 	| TailExp()					//tail e
 	//| BrackedExp()  //(e)
	| LeftParenthness()
	) (ExpTail())*}

//(E...
void LeftParenthness():{}{
	   < LEFTPARENTHESES>Expression()
	   (
	     PairTail()
	   | ApplicationTail()
	   | BrackedTail()	   )}

//to eliminate left recursion
void ExpTail()#void:
{}
{	  (ListTail()
	| AssignmentTail() //
	| SequenceTail()
	| BopTail()	)
}

//listtail
void ListTail():{}{
  < COLONCOLON >Expression()ExpTail()}

//assignment tail
void AssignmentTail():{}{
  < COLONEQUAL >Expression()}

//sequence tail
void SequenceTail():{}{
  < SEMICOLON >Expression()}

//BOP tail
void BopTail()#void:{}{
  Bop()Expression()}

//bracket expression: (e)
void BrackedTail():{}{
  < RIGHTPARENTHESES>}

/*
//list expression: e1::e2
void List():
{}{	Expression()< COLONCOLON >Expression()
}
*/

//pair expression: (e1,e2)
void PairTail():
{
}
{	< COMMA >Expression()<RIGHTPARENTHESES >
}

//application: ( e1 e2 )
void ApplicationTail():
{}
{
  	Expression()<RIGHTPARENTHESES >}

//Uop Expression
void UopExp():
{}{
  Uop()Expression()}

//conditianal: if e1 then e2 else e3 end
void ConditionalExp():
{}
{
  	< IF >Expression()< THEN >Expression()< ELSE>Expression()<END >}

//let expression: let x = e1 in e2 end
void LetExp() :
{
}
{
	< LET >Identifier() < EQUAL > Expression() < IN > Expression() < END >
}

/*
//assignment: e1 := e2
void AssignmentExp():
{}
{	Expression()< COLONEQUAL >Expression()
}

//sequence: e1;e2
void SequenseExp():
{}
{
  Expression()< SEMICOLON >Expression()}
*/
//whileloop: while e1 do e2 end
void WhileLoopExp():
{}
{
  < WHILE >Expression()< DO >Expression()< END >}

//fst: fst e
void FstExp():
{}
{
  	< FST >Expression()}

//snd: snd e
void SndExp():
{}
{
  < SND >Expression()}

//head: head e
void HeadExp():
{}
{
	< HEAD >Expression()}

//tail: tail e
void TailExp():
{}
{
  	< TAIL >Expression()}
//void AdditiveExpression() ://{}//{//  MultiplicativeExpression()//  (//    (//      "+"//    | "-"//    )//    MultiplicativeExpression()//  )*//}////void MultiplicativeExpression() ://{}//{//  UnaryExpression()//  (//    (//      "*"//    | "/"//    | "%"//    )//    UnaryExpression()//  )*//}////void UnaryExpression() ://{}//{//  "(" Expression() ")"//| Identifier()//| Integer()//}void Identifier() :{}{  < IDENTIFIER >}void Integer() :{}{  < INTEGER_LITERAL >}

//valueexp

void Value():{}{
  	(  	  IntValue()
  	| BoolValue()
  	| NilValue()
  	| LOOKAHEAD(2)NopValue()
  	| AnonymousFun()
  	| LOOKAHEAD(2)PairValue()
 	)(ValueTail())*}

//int
void IntValue():{}{
  < INTEGER_LITERAL >}

//bool
void BoolValue():
{}
{	< TRUE>	| < FALSE>
}

//empty list
void NilValue():
{
}
{
  < NIL>}

//nop
void NopValue():
{}{
 	< LEFTPARENTHESES><RIGHTPARENTHESES >}

//anonymous function
void AnonymousFun():
{}{
  	< FUN> Identifier()< ARROW>Expression()}

//pairvalue:
void PairValue():
{}{
  	< LEFTPARENTHESES>Value()< COMMA> Value()<RIGHTPARENTHESES >}

void ValueTail() :{}{
   ListValueTail()}
void ListValueTail():{}{
  < COLONCOLON>Value()}

void Bop()#void:{}{
  	 < PLUS> #PlusOp
	| < MINUS> #MinusOp
	| < TIMES> #TimeOp
	| < DIVIDE> #DivdeOp
	| < BIGGER> #BiggerOp
	| < LESS> #LessOp
	| < AND > #AndOp
	| < OR> #OrOp
	| < EQUAL > #EqualOp}

void Uop()#void:{}
{	< NEGATION > #NegationOp
	| < NOT > #NotOp
}



